package com.example.SpringCaching.services;

import com.example.SpringCaching.entities.MyEntity;
import com.example.SpringCaching.repository.MyRepository;
import lombok.AllArgsConstructor;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.CachePut;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.stereotype.Service;

@AllArgsConstructor
@Service
public class MyService {

    MyRepository repo;

    /**
     *
     * This is Read aside Cache Strategy
     * Read-aside caching (commonly called “lazy loading”) is
     * the most common caching design pattern.
     * With this strategy, your application will first try to
     * request your needed data from a cache. If the data is there,
     * it will return to the caller. If not, it will request the data
     * from the primary data source. Then, it will store the data in the
     * cache for the next attempt and return the data to the caller.
     */
    // if key is not specified then key is generated by
    // combining all the Paramters of the method
    // if parameter is an Object like MyEntity myEntity
    // then it will be #myEntity.id
    // key = "#product.name + '-' + #product.category"
    @Cacheable(cacheNames = "myCache", key="#id")
    public MyEntity getById(int id) {
        return repo.get(id);
    }

    /**
     *
     * With write-aside caching,
     * we are using a centralized, aside cache like with read-aside
     * caching. However, rather than lazily loading items into our cache
     * after accessing it for the first time, we are
     * proactively pushing data to our cache when we write it.
     */
    @CachePut(value = "myCache", key = "#myData.id")
    public MyEntity updateData(MyEntity myData) {
        repo.save(myData);
        return myData;
    }

    @CacheEvict(value = "myCache", key = "#id")
    public void deleteData(int id) {
        repo.delete(id);
    }

    /**
     *
     * Read-through and write-through caching
     * The last two caching design patterns are unique in
     * that all data access goes through the cache directly.
     * Your application will make a request to the cache to fetch
     * the requested data. If the data is available locally,
     * the cache will return it. Otherwise, the cache itself will do
     * the work to fetch the data from the primary data source, cache
     * the data, and return it to you.
     *
     * Cannot be implemented this simply will require infra support
     *
     */
}
